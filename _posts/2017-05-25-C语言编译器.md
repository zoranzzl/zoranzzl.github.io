
---
layout: post
title: T-SQL编程基础习题
author: zoranzzl
---


# 构建一个简单的C语言编译器


前言

最开始知道本学期有《编译原理》这门课的时候，还是挺兴奋的，感觉好高大上。尤其是在知道《编译原理》这本书“拽根布克”的名头之后，更是是心存敬畏。可就在上了两三周可之后，就彻底懵逼了，内容晦涩难懂，关键老师还觉得我们都懂，慢慢就放弃了。快要考试了，也是蛮慌的。最坑的是还有实验作业：实现一个编译器。偶然的机会发现了一个菜鸟教程，也不知道好不好用（我能不能看懂），但还是想看看教程，一步步做下去，争取完成一个简单的C语言编译器。

## 1.设计

首先要说明的是，虽然标题是编译器，但实际上我们构建的是C语言的解释器，意味着我们可以像运行脚本一样去运行C语言的源代码文件。这么做的理由有两点：

1. 解释器与编译器尽在代码生成阶段有区别，而其他方面如词法分析、语法分析是一样的。
2. 解释器需要我们实现自己的 虚拟机与指令集，而这部分可以帮助我们了解计算机的工作原理。

### 编译器的构建过程

一般来说，编译器的编写分为3个步骤：

1. 词法分析器，用于将字符串转化为内部的表示结构。
2. 语法分析器，将词法分析器得到的女标记流（token）生成一棵语法树。
3. 目标代码的生成，将语法树转化为目标代码

目前已经有很多强大工具可以帮助我们处理阶段1和2，比如flex用于词法分析，bison用于语法分析。但它们的功能过于强大，屏蔽了许多实现上的细节，对我们的学习帮助不大。所以这些功能要依靠纯手写实现。

所以我们会按照以下步骤来构建我们的编译器：

1. 构建我们自己的虚拟机以及指令集。以后生成的目标代码就是我们的指令集。
2. 构建词法分析器
3. 构建语法分析器

### 编译器框架

我们的编译器主要包括4个函数：

1. <kbd>next( )</kbd> 用于词法分析，获取下一个标记，他将自动忽略空白字符。
2. <kbd>program( )</kbd>语法分析的入口，分析整个C语言程序。
3. <kbd>expression(level)</kbd>用于解析一个表达式
4. <kbd>eval( )</kbd>虚拟机的入口，用于解释目标代码。

这里有一个单独用于解析“表达式”的函数<kbd>expression</kbd>是因为表达式在语法分析中相对独立且比较复杂，所以将其单独作为一个模块（函数）。

下面是相应的源代码：

```
#include<stdio.h>
#include<stdlib.h>
#include<memory.h>
#include<string.h>

int token;           //当前输入
char *src,*old_src;  //指向源代码字符串的指针
int poolsize;        //文本/数据/栈的默认大小
int line;            //行号

void next(){
   token = *src++;
   return;
}

void expression(int level){
   //什么都不做
}

void program(){
   next();          //获取下一个输入
   while(token > 0){
       printf("token is:%c\n",token);
       next();
   }
}

int eval(){
   //还是什么都不做
   return 0;
}

int main(int argc,char **argv){
   int i,fd;
   argc--;
   argv++;

   poolsize = 256 * 1024;    //任意大小
   line = 1;

   if((fd = open(*argv,0)) < 0){
      printf("could not open(%s)\n",*argv);
      return -1;
   }

   if(!(src = old_src = malloc(poolsize))){
       printf("could not malloc(%d) for source area	\n",poolsize);
       return -1;
   }

   //读取源文件

   if ((i = read(fd,src,poolsize-1)) <= 0){
       printf("read() returned %d\n",i);
       return -1;
   }

   src[i] = 0;      //添加文件终止符
   close(fd);

   program();
   return eval();
}

```


上述代码的流程为：读出一个文件（内容为C语言代码），逐个读取文件中的字符，并输出。这里需要的是每个函数的作用，后面的学习将逐个填充每个函数的功能，最终构建起编译器。

这就有了一个最简单的编译器：什么都不干的编译器，下一章将实现其中的<kbd>eval</kbd>函数，即我们自己的虚拟机。

## 2.虚拟机

本章要实现构建一台虚拟的电脑，设计并运行我们自己的指令集，即自己实现一套汇编语言。它们将作为我们编译器输出的目标代码。

### 计算机内部的工作原理

计算机中有三个基本部件需要我们关注：CPU、寄存器及内存。

- 代码（汇编指令）以二进制的形式保存在内存当中；
- CPU从内存中一条条的加载指令并执行；
- 程序运行的状态保存在寄存器当中。

##### **内存**

内存用于存储数据，这里的数据可以是代码，也可以是其他数据。现代操作系统在操作内存时，并不是直接处理“物理内存”，而是操作“虚拟内存”。虚拟内存可以理解为一种映射，它的作用就是屏蔽了物理的细节。例如32位的机器中，我们可以使用的内存地址位<kbd>2^32=4 G</kbd>，而电脑上的实际内存可能只有<kbd>256 M</kbd>.操作系统将我们使用的虚拟地址映射到了实际的物理内存上。

还需要了解的是：进程的内存会被分成几个段：

1. 代码段（text)用于存放代码（指令）。
2. 数据段（data）用于存放初始化了的数据，如：<kbd>int i = 10 ;</kbd>,就需要存放到数据段中。
3. 未初始化数据段（bss）用于存放未初始化的数据，如<kbd>int i[1000];</kbd>,因为不关心其中的真正数值，所以单独存放可以节省空间，减少程序的体积。
4. 栈（stack）用于处理函数调用相关的数据，如调用帧（ calling frame )或是函数的局部变量等。
5. 堆（heap）用于为程序动态分配内存。

它们在内存中的位置类似于下图：

![](https://github.com/zoranzzl/zoranzzl.github.io/blob/master/_posts/images/%E5%86%85%E5%AD%98%E6%AE%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.JPG?raw=true)

我们的虚拟机并不打算模拟完整的计算机，因此为了简单起见，我们只关心三个内容：代码段、数据段以及栈。其中的数据段我们只用来存放字符串，因为我们的编译器并不支持初始化变量，因此也不需要为初始化数据段。

当用户的程序需要分配内存时，理论上虚拟机需要维护一个堆用于内存分配，但实际中实现起来较为复杂且编译无关，因此我们引入一个指令<kbd>MEST </kbd>，使我们能直接使用编译器（或者说解释器）中的内存。

综上，我们需要首先在全局添加如下代码：


